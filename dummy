Thanks a lot for the feedback and for raising both the Neo4j governance concern and the Stardog angle.

On Neo4j: I agree that, used tactically, a flexible LPG can drift and become hard to govern after a few years. For this initiative though, the intent is to use Neo4j as a strategic, ontology-driven KG, not as an ad-hoc graph store. We’re planning to mitigate the “ungovernable in a couple of years” risk by:

Ontology-first modelling – the policy / procedure / control model is defined in an enterprise ontology (FIBO/SBVR/BPMN-aligned), and we won’t allow arbitrary labels/relationships to be introduced outside that model.

Git + PR–driven changes – all schema and relationship changes will be authored in Git, reviewed by SMEs/architecture, and applied to Neo4j via automated migrations (no direct model editing in prod).

Constraints and validation – using Neo4j constraints and SHACL-style / custom validation checks to detect model violations and prevent uncontrolled schema growth.

Enterprise edition – we would use the Enterprise build (not Community) to get HA, RBAC and operational support in line with other strategic platforms.

I’d be very happy for you to speak to colleagues or previous clients using Neo4j – external experience on what has and hasn’t worked long-term would be useful input to refine the governance model rather than a blocker to using Neo4j.

On Stardog: we’ve already had an initial session with them to understand their value around RDF/OWL reasoning, SHACL, and LLM/vector integration. They are clearly strong in the formal Semantic Web space. However, for this specific “codifying the bank” use case, most of our requirements are around ontology-aligned modelling, multi-hop traversal, lineage and KG-RAG/agent integration, which Neo4j already covers well as an approved technology. The incremental benefit of full OWL-level reasoning doesn’t currently justify the additional licensing cost, onboarding effort and new infra pattern for a second strategic graph engine, especially given others are indeed catching up in this space.

My proposal is:

We proceed with Neo4j as the strategic KG platform for this initiative, with the governance model above to address schema drift.

We keep Stardog on the radar for future, more reasoning-heavy scenarios or a targeted PoC if/when we find clear limits with Neo4j’s graph-based reasoning and there is appetite to introduce an RDF/OWL stack.

I’ve reflected this positioning in the clear choice analysis, but happy to adjust if you’d like it framed differently.


MNPI Platform – Interim vs Strategic State Scope
Purpose

Provide transparency on capabilities delivered now (interim) versus capabilities deferred to the strategic target state, while demonstrating that the interim solution does not deviate from the approved direction.

Interim State (Phase 1) – Scope Clarity
✅ Included

Dedicated MNPI Starburst instance as the secure query and virtualisation layer

Direct connectivity to MNPI source systems (no intermediate MNPI storage)

Federated access to non-MNPI Hadoop cluster for enrichment

On-demand virtual CDAs only (no materialisation)

In-transit encryption enforced by Starburst

Application-layer MNPI entitlement with IRS/GIRS integration

Column-level masking and policy enforcement via Ranger

Small-scale, low-volume MNPI use case support

Design aligned for seamless future expansion

❌ Not Included

Dedicated MNPI Hadoop or S3 processing/storage layer

Physical or persistent MNPI data assets

MNPI ingestion pipelines and landing zones

Per-use-case encryption zones and KMS key lifecycle management

Platform-level MNPI entitlement embedded within Starburst

Enterprise-wide MNPI monitoring and breach analytics

Full metadata lineage integration via DataHub

Large-scale MNPI transformations or ML workloads

Strategic Target State – Scope Clarity
✅ Included

Dedicated MNPI ingestion, processing, and storage layer (Hadoop / on-prem S3)

Physical MNPI data assets with lifecycle management

Per-use-case encryption zones and centralized KMS/HSM integration

Platform-driven MNPI entitlement across ingestion, processing, and consumption

End-to-end monitoring and breach detection across all layers

Enterprise metadata classification and lineage via DataHub

Scalable MNPI analytics, transformations, and future AI/ML workloads

Full regulatory-grade governance and auditability

❌ Not Included

Direct MNPI source-to-consumer access without platform governance

Ad-hoc entitlement handling at application level only

Tactical, use-case-specific shortcuts used in interim phase


Please let me know if you have any further questions or would like to discuss this in more detail.Clear choice recommendation in one line

Neo4j is the best overall fit for the Codifying the Bank KG (ontology-aligned objects + deep traversal + lineage + agent/KG-RAG integration) within current bank constraints.
Stardog becomes the best fit only if OWL/SHACL-first semantics and/or live federation is a hard runtime requirement.
NebulaGraph is compelling only if scale/distribution becomes the primary driver (very large graphs/high concurrency), but it’s weaker for semantic governance out of the box.

Table 1 — Use case requirements evaluation (business architecture)
Requirements	Need	Neo4j	Spanner DB (Spanner Graph)	FalkorDB	Quantexa	NebulaGraph	Stardog	Best fit
1) Compliance Checker (lineage + orphan detection)	End-to-end lineage: obligation → policy → procedure → control → rule → system → evidence → customer; find gaps/orphans	• Strong multi-hop traversal for lineage
• Easy orphan detection via pattern queries
• Good for audit/explainability with explicit relationships	• Possible but tends to become table/join heavy
• Lineage logic often pushed into application/query layer	• Traversal works well
• Validation/constraint layer is DIY	• Strong lineage for entity/txn networks
• Not naturally obligation→policy→procedure modelling	• Strong traversal at scale
• Semantic validation is DIY	• Strong constraints/validation model (SHACL-first)
• Good fit where “compliance constraints” are primary	Neo4j (practical + approved); Stardog if SHACL/OWL-first is mandatory
2) Simplifying Regulatory Change (impact + simulation)	Detect impacted policies/procedures/controls/rules; scenario analysis (cost/resourcing/control gaps); AI-assisted rule drafting	• Natural impact propagation over relationships
• Good “blast radius” queries and change diffs
• Strong foundation for agent-assisted drafting	• Feasible but requires more modelling discipline + glue
• “Propagation” becomes coded logic	• Graph-capable; logic is custom-built	• Better for risk/entity context changes
• Less for formal policy rule propagation	• Strong for dependency graphs at scale
• Semantic “what changed” still custom	• Strong for semantic change analysis if modelled in OWL/SHACL
• Heavier onboarding effort	Neo4j
3) Alignment / Consistency Agent (global vs market variance)	Compare global/regional/market procedures; highlight inconsistencies; recommend harmonisation	• Hierarchies + variants model cleanly
• Cross-reference via shared anchors (terms/data points/rules)
• Works well with embedding similarity + graph	• Achievable but usually less natural than a KG-first model
• Variance checks become heavier queries	• Hierarchy modelling possible
• Consistency logic is DIY	• Strong “entity consistency” (ER)
• Not designed for procedural variance	• Can do hierarchical traversal at scale
• Similarity/validation is DIY	• Strong semantics + constraint validation
• Skills/tooling shift (RDF/SPARQL)	Neo4j
4) Query Layer (graph APIs + NLQ / KG-RAG)	BA queries + agent queries (multi-hop, explainable); expose via API; KG-RAG	• Cypher expressive for BA questions
• Practical KG-RAG/agent patterns
• Strong for explainability	• Graph queries often degrade into join-style thinking
• KG-RAG typically externalises vectors and adds glue	• Fast graph retrieval
• Fewer standard agent/KG-RAG patterns	• Strong platform APIs for its use cases
• Less “open KG query layer”	• Query works; ecosystem for KG-RAG is smaller	• Strong semantic querying, can be powerful
• Different dev/query paradigm	Neo4j
5) Deterministic Workflow & Rule Execution (rules → engine + lineage)	Represent rules + link to policy/procedure/control; export to rule engines (e.g., REME); keep full traceability	• Rules as first-class nodes/edges
• Traceability is natural and explainable
• Straightforward export to JSON/DSL	• Rules often stored as rows + metadata
• Lineage reconstructed in app logic	• Possible to store a rule graph
• Governance + validation DIY	• Not a rules repository; more analytics/ER platform	• Possible at scale but conventions DIY	• Strong constraints consistency checking
• Export patterns require semantic mapping	Neo4j
6) Agent Operating Procedures (agentic flows)	Encode procedural steps, preconditions, approvals, exceptions; drive agentic flows	• Natural “agent-walkable” graphs (steps + transitions)
• Good for human-in-loop approvals and audit trails	• Typically needs external workflow engine to be primary
• DB is a backing store	• Graph structure supports flows
• Less standard governance patterns	• Best for case/investigation flows in its domain	• Works but ops overhead higher	• Works well if procedures are represented semantically
• Heavier operational adoption	Neo4j
7) Cross-referencing duplication & inconsistency	Detect duplicate data points/rules; contradictions across areas	• Strong pattern matching across shared semantic anchors
• Supports contradiction detection via relationship patterns	• Possible but more brittle/complex queries	• Fast detection possible; validation DIY	• Good duplication/ER for entities
• Less rule-contradiction oriented	• Scales scanning well; semantics DIY	• Strong constraint-based inconsistency detection	Neo4j (practical); Stardog if constraint-first enforcement dominates
8) Distributed sources / federation	Sources “everywhere”; avoid copying everything; real-time access when needed	• Fits your target pattern: CI DP/fabric integrates data; KG stores knowledge objects + stable IDs
• Resolve live values via CI DP APIs	• Strong native GCP integration; federation not core	• Ingest/sync into graph; not federation	• Platform integrates multi-source in its own model	• Ingest/sync into graph; not federation	• Strong virtual graphs/federation if runtime federation is required	Neo4j given CI DP/fabric is the integration layer; Stardog only if live federation is a hard requirement
Table 2 — Technical capabilities evaluation
Criterion	Neo4j	Spanner DB (Spanner Graph)	FalkorDB	Quantexa	NebulaGraph	Stardog	Best fit
Core paradigm	Labelled Property Graph DB	Distributed relational DB with graph patterns	High-perf graph engine (RedisGraph lineage)	Decision-intelligence platform with graph/ER	Distributed property graph DB	RDF/OWL semantic KG (triples)	Neo4j (enterprise KG); Stardog (semantic web)
Commercial & licensing	Enterprise-grade option; already approved in bank	Managed GCP service pricing	OSS-friendly; enterprise readiness depends on support model	Proprietary; existing contract leverage	OSS/enterprise options; approval unknown	Proprietary enterprise; onboarding/licensing heavier	Neo4j (fastest to production in-bank)
Data model semantics	Flexible nodes/edges/properties; great for “knowledge objects”	Graph often mapped from tables; semantics mostly app/schema-led	LPG-like; fast operations	Strong contextual entity model	LPG distributed partitions	Ontology-native (triples + ontology)	Neo4j / Stardog
Semantic / ontology fit	Ontology-aligned modelling + governance patterns; “semantic modelling” via structure and validation jobs	Semantics usually implemented outside DB (schema/app)	DIY semantics	Not ontology-first for policy/procedure/control	DIY semantics	Best-in-class OWL/SHACL-first semantics	Stardog (formal); Neo4j (practical + sufficient for current BA needs)
Reasoning / rule checking	Practical graph-based reasoning: traversals + constraints + validation jobs; OWL-level reasoning not native	Mostly SQL/GQL + app logic	DIY	Mostly platform analytics/scoring	DIY	Strong formal reasoning + constraint validation	Neo4j operationally; Stardog for formal OWL/SHACL-first
Graph modelling traversal / overhead	Excellent traversal & patterns; moderate ops	Low ops (managed); graph usage needs careful modelling	Very fast; ops/governance patterns less mature	Vendor-managed but heavier footprint	Strong at scale; higher cluster ops overhead	Strong semantics; ops/onboarding heavier	Neo4j (balance); Nebula if scale dominates
Data security & governance	Strong with enterprise features + bank controls; needs agreed pattern	GCP-native IAM/guardrails	Mostly infra-led; enterprise features vary	Strong vendor governance model	Mostly infra-led	Strong semantic governance; enterprise model	Neo4j Enterprise (bank fit) / Spanner (GCP-native)
GCP onboarding	Future: GKE/VM once pattern approved (on-prem now)	Native GCP managed	Deploy on compute; DIY	Platform onboarding effort	Deploy distributed cluster; DIY	Deploy + integrate; approvals heavier	Spanner (native); Neo4j once cloud pattern approved
Data source integrations	Best with curated CI DP feeds + stable IDs; ETL/sync is straightforward	Strong integration with GCP pipelines	ETL into graph	Platform connectors in its domain	ETL into cluster	Federation/virtual graph mapping capability	Neo4j for your CI DP pattern; Stardog if federation mandatory
AI / KG-RAG integrations	Strong practical integration with agent frameworks; good hybrid graph+vector patterns	Usually external vector + glue	DIY	More vendor-driven patterns	DIY	Strong semantic grounding; different toolchain	Neo4j
Alignment/consistency cross-checking	Strong: shared anchors + traversal; supports variance detection	Achievable but heavier	DIY	Entity-centric consistency	DIY	Constraint-driven validation	Neo4j
Version control / temporal context	Supports “as-of” modelling patterns (validFrom/validTo, change events); aligns to Git/PR metadata ingestion	Temporal modelling possible; “as-of graph” requires design	Possible; patterns less proven	Entity lifecycle oriented	Possible; conventions DIY	Provenance patterns possible; still requires modelling	Neo4j
Operational maturity / ecosystem	Mature enterprise KG DB; proven ops practices	Mature DB platform; graph usage still emerging	Smaller enterprise maturity	Mature platform in its niche	Mature for very large graphs; ops heavier	Mature semantic KG vendor; adoption/onboarding heavier	Neo4j overall
Two additional criteria worth including (because they came up in your stakeholder reviews)
Added criterion	Neo4j	Spanner DB	FalkorDB	Quantexa	NebulaGraph	Stardog	Best fit
Federation / virtual graphs	Not native (fits your CI DP/fabric approach instead)	Not core	No	Platform-specific	No	Strong native capability	Stardog (only if required at runtime)
Developer productivity (query language + skills)	Very strong (Cypher + wide adoption)	SQL/GQL (newer graph mental model)	Cypher-like but smaller community	Vendor APIs/DSL	nGQL; smaller community	SPARQL/semantic stack learning curve	Neo4j
Final “clear choice” wording you can use with your chief architect

Neo4j is the recommended KG store for the Codifying the Bank initiative because it best supports the core requirements—ontology-aligned knowledge objects, multi-hop traversal, lineage, cross-referencing, deterministic rule workflows, and practical KG-RAG/agent integration—while also fitting the bank’s current approval and on-prem deployment constraints.
Stardog remains a strong alternative if the programme later mandates OWL/SHACL-first semantics and/or real-time federation, but its incremental benefit does not currently outweigh onboarding/licensing/timeline overhead given your CI DP + data fabric architecture.
NebulaGraph is a scale-driven alternative if the graph size/concurrency becomes the dominant driver, but it is less aligned to semantic governance needs out of the box.

If you want, I can also produce:

a one-slide executive summary of the above (bullet “why Neo4j” + “when Stardog/Nebula would win”), and

a risk + mitigation appendix (schema drift, approval constraints, federation questions, and how you address them with CI DP + governance).


3.5 NebulaGraph

Distributed labelled property graph database designed for high-scale graph storage and traversal.

Strong for large graphs and high-concurrency multi-hop queries (scale-out architecture).

Uses nGQL (with partial openCypher-style patterns), but has a smaller ecosystem than Neo4j for enterprise KG tooling.

Less semantic/ontology tooling out of the box (ontology validation and rule checks typically implemented via application/validation services).

Best suited when scale and throughput are the dominant drivers, rather than formal semantic governance.

3.6 Stardog

Semantic graph platform based on RDF triples with OWL reasoning and SHACL-style constraint validation.

Strong for ontology-first governance, standards alignment (e.g., semantic modelling patterns), and formal rule/consistency validation.

Supports virtual graph / federation patterns (query data in place via mappings when needed).

Uses SPARQL and Semantic Web concepts, which may require specialist skills and onboarding compared to property-graph/Cypher stacks.

Best suited when formal semantics (OWL/SHACL) and/or federation are hard requirements for the KG at runtime.
